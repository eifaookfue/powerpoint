ソケットの共有のイメージがわかりません。マスタープロセスが作成したソケットをどうやって共有するのですか？
どのようなシステムコールが使われているのですか？

Nginxでは、**マスタープロセスが作成したリスニングソケットをワーカープロセスに共有**することで、複数のワーカープロセスが同じポートをリッスンできるようにしています。このソケット共有の仕組みは、UNIX系OSの仕組み（`fork()`システムコール）を活用して実現されています。

---

## **1. ソケット共有の仕組み**

### **a. ソケット作成**
1. **マスタープロセスがリスニングソケットを作成**します。
   - マスタープロセスは、`socket()` システムコールを使用してリスニングソケットを作成します。
   - 作成されたソケットは、指定されたポートでクライアントからの接続を受け入れるためのものです。

2. **ソケットのバインドとリッスン**
   - ソケットは `bind()` システムコールでポートにバインドされ、`listen()` システムコールで接続待ちの状態になります。

### **b. ソケットの共有**
- **`fork()` システムコール**:
  - マスタープロセスはリスニングソケットを作成した後、`fork()` を使用してワーカープロセスを生成します。
  - `fork()` により、子プロセス（ワーカープロセス）はマスタープロセスのメモリ空間をコピーします。このとき、マスタープロセスが作成したリスニングソケットもコピーされます。

- **共有ソケットの特性**:
  - `fork()` によってコピーされたソケットは、マスタープロセスとすべてのワーカープロセスで共有されます。
  - 各プロセスは、この共有ソケットを介してリクエストを受け取ることができます。

---

## **2. ソケット共有の具体的な流れ（システムコール）**

以下は、Nginxのソケット共有の流れと、それに関連する主要なシステムコールの概要です：

### **1. ソケット作成**
- マスタープロセスがリスニングソケットを作成します。
  ```c
  int sock = socket(AF_INET, SOCK_STREAM, 0);  // IPv4, TCPソケット
  ```

### **2. ソケットオプションの設定**
- ソケットの再利用や競合防止のため、必要なオプションを設定します。
  ```c
  int opt = 1;
  setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));  // ソケットの再利用
  ```

### **3. ソケットのバインド**
- ソケットを特定のIPアドレスとポートにバインドします。
  ```c
  struct sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = INADDR_ANY;  // すべてのインターフェースで受信
  addr.sin_port = htons(80);          // ポート80
  bind(sock, (struct sockaddr*)&addr, sizeof(addr));
  ```

### **4. 接続待ち状態にする**
- ソケットをリスニング状態にします。
  ```c
  listen(sock, SOMAXCONN);  // 接続待ちキューのサイズを設定
  ```

### **5. ワーカープロセスを生成**
- マスタープロセスが `fork()` を使用してワーカープロセスを生成します。
  ```c
  pid_t pid = fork();
  if (pid == 0) {
      // ワーカープロセス
  }
  ```

- **共有の仕組み**:
  - `fork()` 後、すべてのワーカープロセスは同じリスニングソケット（`sock`）を参照します。
  - ソケットはファイルディスクリプタとしてOSのファイルテーブルに登録され、プロセスごとに同じファイルディスクリプタ番号でアクセスできます。

### **6. クライアント接続の受け入れ**
- ワーカープロセスがリクエストを受け付ける際、`accept()` システムコールを呼び出します。
  ```c
  int client_sock = accept(sock, NULL, NULL);
  ```

- **競合防止**:
  - 複数のワーカープロセスが同じソケットで `accept()` を呼び出すと競合が発生する可能性があります。
  - この問題を防ぐため、Nginxは **アクセプト・ミューテックス（`accept_mutex`）** を利用して競合を管理します。

---

## **3. システムコールの役割まとめ**

| **システムコール** | **役割**                                                                                  |
|--------------------|------------------------------------------------------------------------------------------|
| `socket()`         | リスニングソケットを作成します。                                                          |
| `setsockopt()`     | ソケットオプションを設定（例: `SO_REUSEADDR` や `SO_REUSEPORT`）して、再利用可能にします。    |
| `bind()`           | ソケットをIPアドレスとポートにバインドします。                                              |
| `listen()`         | ソケットを接続待ち状態にします。                                                          |
| `fork()`           | 子プロセス（ワーカープロセス）を生成し、ソケットを共有します。                              |
| `accept()`         | クライアントからの接続を受け入れ、通信のための新しいソケットを作成します。                  |

---

## **4. ソケット共有のイメージ**

以下のように、リスニングソケットはすべてのプロセスで共有されます。

```plaintext
マスタープロセス
   ├── リスニングソケット (ポート80)
   ├── ワーカープロセス1 ─── 共有ソケット (リクエスト処理)
   ├── ワーカープロセス2 ─── 共有ソケット (リクエスト処理)
   ├── ワーカープロセス3 ─── 共有ソケット (リクエスト処理)
```

---

## **5. 注意点**

1. **ソケットは共有されるが独立して処理**:
   - 共有されたソケットを通じて、ワーカープロセスは独立してリクエストを処理します。
   - ワーカープロセス間で直接データをやり取りすることはありません。

2. **競合管理が重要**:
   - `accept()` で競合が発生しないように、`accept_mutex` や `SO_REUSEPORT` の利用が推奨されます。

---

## **6. まとめ**

- マスタープロセスがリスニングソケットを作成し、`fork()` を使ってワーカープロセスに共有します。
- UNIXの仕組みで、ソケット（ファイルディスクリプタ）が複製されるため、すべてのワーカープロセスが同じポートで接続を受け入れることが可能です。
- 実際のクライアントリクエストの割り当ては、`accept()` を呼び出したプロセスに基づいて行われ、Nginx独自のロック機構（`accept_mutex`）で競合を防ぎます。